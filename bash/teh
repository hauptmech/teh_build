#!/bin/bash
#
# Traveler Hauptman, Istituto Italiano di Tecnologia, 20 Aug 2013
# 
# Repo Build Publish helper utility

cat > /dev/null <<"==="

This development automation tool requires that some conventions are followed in order for it's 
heuristics to function correctly. The following are the conditions...

'build' 'rebuild' and 'publish' use the $PROJECT/build directory to detect if a project is active. Likewise
the cmake FindPackage scripts check for a $PROJECT/build directory. 








===

SCRIPTNAME=$0
CWD=$(pwd)

# If local or user global config file exists, use it, otherwise error.
if [ -f ./.tehrc ]; then
	source ./.tehrc
elif [ -f ~/.tehrc ]; then
	source ~/.tehrc
else
	echo -e "\n[ERROR] Could not find config file (~/.tehrc or ./.tehrc). It needs the following variables defined...\n"
	echo -e "SERVER_IP=90.147.26.149;SERVER_USER=drc;SERVER_NAME=debiangpm;REPOSITORY=raring_drc\n"
fi

function check_for_development_root
{
	#Always operate from .development_root
	if [ -f ./.development_root ]; then
		pushd . &>/dev/null
	elif [ -f ../.development_root ]; then
		pushd .. &>/dev/null
	elif [ -f ../../.development_root ]; then
		pushd ../.. &>/dev/null
	elif [ -f ../../../.development_root ]; then
		pushd ../../.. &>/dev/null
	elif [ -f ../../../../.development_root ]; then
		pushd ../../../.. &>/dev/null
	elif [ -f ../../../../../.development_root ]; then
		pushd ../../../../.. &>/dev/null
	else 
		echo -e "\nCould not find .development_root! Change to a directory closer to it before running $0\n"
		exit 1
	fi
}

function locate_project
{
	if [ -z $1 ]; then 
		while [ ! -f .development_root ] && [ ! -d ./build ] && [ ! -d dev ]; do cd ..; done
		if [ -d ./build ]; then
			TARGET=$(pwd)
			echo -e "\nTARGET is $TARGET"
		else
			echo -e "\n[ERROR] You need to specify a target project. (Though I can guess the project if a PROJECT/build directory exists.\n"
		fi
	else
		TARGET=${1%/}
	fi	
}

function usage 
{
	echo $1
	#sed  -e "s|teh|${1}|"  <<"==="
	sed  -e "s|teh|${1}|"  <<"==="

Usage:

  teh list                    # List available repositories

  teh get <project_name>      # Git clone a project if it's found
  teh new <project_name>      # Create a new repository from template

  teh build <project_name>    # Create new <project_name>/build; cmake ..
  teh publish <project_name>  # Make packages and upload to server


  teh setup                   # Initial setup
  teh setup_ssh_keys          # Install the keys for the server
  teh update                  # apt-get update the project packages repository.


  publish:  Publish auto increments the version number, then runs cpack to build
	          the debian packages, the uploads them to the server for others to
	          use.

  build:    Build creates a clean build of a <project> by removing the 
	          <project>/build directory, recreating it, and the running first
	          cmake and then make.
===

}
# Helper function to make sure git set up correctly
# Parameter $1 is the git key to check (typically 'name' or 'email')
function git_global 
{
	git config --global --get user.$1 &>/dev/null
	RET=$?
	while [ ! $RET -eq 0 ]; do
		echo -e "\n!!! The git global user info is not set..\n"
		read -p "Enter your $1 for git log messages: " gitvalue
		git config --global --add user.$1 $gitvalue
		git config --global --get user.$1 &>/dev/null
		RET=$?
	done
}

function check_for_git_extension
{
		FNAME=${1}
		if [ ${#FNAME} -gt 4 ]; then 
			FNAME=${FNAME:0:${#FNAME} - 4}
			if [ $FNAME = ".git" ]; then
				echo "ERROR: Re-run the command without the .git extension... I'll add that automatically."
				exit 1
			fi
		fi
}		

function abort_if_project_does_not_exist
{
	if [ ! -d $1 ]; then
		echo "ERROR: The directory $1 (and hence the project $1) does not exist!"
		exit
	fi
}

function abort_if_project_is_not_active
{
	if [ ! -d $1/build ]; then
		echo "ERROR: The build directory for $1 does not exist (and hence $1 is deactivated)!"
		exit
	fi }

# Get ssl certificates, install them, and add package repository to sources.list.d
function setup_https_package_repo
{
		echo "function setup_https_package_repo failed because it needs to be checked for correctness first!"
		exit
		mkdir -p /usr/local/share/ca-certificates
		sudo scp $SERVER_USER@$SERVER_NAME:/etc/ssl/certs/traveler.crt /usr/local/share/ca-certificates
		sudo update-ca-certificates

		sudo sh -c "echo \"deb https://$SERVER_NAME/ubuntu ${REPOSITORY}/\" > /etc/apt/sources.list.d/${REPOSITORY}.list"
		sudo apt-get update
		
		if [ ! $? -eq 0 ]; then
			echo "Something went wrong! Ask someone for help..."
		fi
}
#Add package repository to sources.list.d
function setup_http_package_repo
{
		echo "deb http://$SERVER_NAME/ubuntu ${REPOSITORY}/" > ~/.${REPOSITORY}.list
		sudo cp ~/.${REPOSITORY}.list /etc/apt/sources.list.d/${REPOSITORY}.list
		sudo apt-get update
		
		if [ ! $? -eq 0 ]; then
			echo "Something went wrong! Ask someone for help..."
		fi
}
# Add server to hosts file and .tehrc
function setup_hosts
{
		sudo echo "$SERVER_IP	$SERVER_NAME" >> /etc/hosts
}

#Grabs the shared private key from the server and installs it.
#We should create individual keys instead!!!
function setup_ssh_keys
{
		echo -e "\nWe will now create a RSA key file and teel our server ($SERVER_NAME) abount"
		echo -e "it so you don't have to type the password everytime you access the server.\n"
		mkdir -p ~/.ssh
		cd ~/.ssh
		# Create a filename with some random in case others are using the same username
		KEYFILE=$LOGNAME$RANDOM
		# Generate key
		ssh-keygen -t rsa -N "" -f $KEYFILE
		echo -e "\nCopying the key to the server. Enter your password when requested.... \n"
		ssh-copy-id -i $KEYFILE $SERVER_USER@$SERVER_NAME

		echo -e "\nAdding the login details to ~/.ssh/config\n"

		echo "Host $SERVER_NAME" >> ~/.ssh/config
		echo "IdentityFile ~/.ssh/$KEYFILE" >> ~/.ssh/config
		echo "User $SERVER_USER" >> ~/.ssh/config
		echo "" >> ~/.ssh/config
}

# apt-get update on a specific repository
function update_packages
{

sudo apt-get update -o Dir::Etc::sourcelist="sources.list.d/$1" \
-o Dir::Etc::sourceparts="-" -o APT::Get::List-Cleanup="0"
}

# apt-get update on a specific repository
function upgrade_packages
{
	update_packages $1
	sudo apt-get upgrade -y --allow-unauthenticated -o Dir::Etc::sourcelist="sources.list.d/$1" \
	-o Dir::Etc::sourceparts="-" -o APT::Get::List-Cleanup="0"
}

function new_repo 
{

	check_for_git_extension $1
	

	# We need to make a multi-level directory if necessary.
	echo -e "\nChecking to see if this repo is on the server...\n"
	echo "[ ! -d ~/git/${1}.git ] && mkdir -p ~/git/${1}.git" | ssh $SERVER_USER@$SERVER_NAME /bin/bash &>/dev/null
	if [ $? -eq 0 ]; then
		existed=0
		echo "There is no repo of this name on the server yet."
	else
		existed=1
		echo "This repo appears to exist already..."
		echo "Use $SCRIPTNAME get $1 to get it if you want it."
		exit
	fi

	if [ ! -d ${1} ]; then
		echo -e "\nWe need to create the directory locally first. Choose a template:\n"
		mkdir -p $1
		select what_to_do in "Use bin (exe) template?" "Use library template?" "Abort!"; do
			case $REPLY in
				1) 
					cd Demo_Application; git checkout latest; cd ..
					cp -ar Demo_Application/* $1; rm -rf $1/.git $1/build; break;;
				2) 
					cd Demo_Library; git checkout latest; cd .. 
					#TODO: return to previous state (tag current before chkout. delete tag after done)
					cp -ar Demo_Library/* $1; rm -rf $1/.git $1/build; break;;
				3) echo "Aborting new repo!"; exit ;;
			esac
		done
		cd $1; git init; git add .; git commit -m 'First!';
		git remote add origin $SERVER_USER@$SERVER_NAME:/home/$SERVER_USER/git/${1}.git
		echo -e "\nCreating this repo on the server...\n"
		echo "git init --bare ~/git/${1}.git" | ssh $SERVER_USER@$SERVER_NAME /bin/bash &>/dev/null
		git push origin master
		cd ..
	elif [ -d $1/.git ]; then
		if [ $existed -eq 0 ]; then
			echo "There is already a git repo with that name locally."
			echo -e "      Pushing it up to the new repo on the server!\n"
			cd $1; 	
			git remote rm origin &>/dev/null; \
			git remote add origin $SERVER_USER@$SERVER_NAME:git/${1}.git &>/dev/null
			echo -e "\nCreating this repo on the server...\n"
			echo "git init --bare ~/git/${1}.git" | ssh $SERVER_USER@$SERVER_NAME /bin/bash &>/dev/null

			git push origin master
			cd ..
			exit
		else
			echo "There is already a git repo with that name locally."
			echo "      Aborting with no changes made."
			exit
		fi
	fi

}
############################ Script starts here ##################################

# If called with no parameters, print usage
if [ $# -lt 1 ]
then
	usage $0
	exit
fi

if [ $# -eq 2 ]; then
	TARGET=${2%/}
	echo -e "\nTARGET is $TARGET \n"
fi

# Check that git is setup, force setup if not.
git_global name
git_global email

# Check which command was given
case "$1" in

	help) # Print out help
		usage $0
		;;

	list) echo "echo '';ls ~/git | sed -e 's/.git//'" | ssh $SERVER_USER@$SERVER_NAME /bin/bash
		;;

	locate) locate_project
	;;
	setup) 

		if [ -d ${TARGET} ]; then 
			echo -e "\nDirectory ${TARGET} already exists.\n" 
            read -p "Are you sure you want me to add DRC specific stuff here? [y/N] " mess_with_this
            mess_with_this=${mess_with_this:-N}
            if [ ! $mess_with_this = "Y" ] || [ ! $mess_with_this = "y" ]; then 
				exit 
			fi
		else
			mkdir -p ${TARGET}
		fi

		echo -e "Cloning Build_Tools, CMakeModules, Demo_Library, Demo_Application"
		#sudo apt-get install -y --allow-unauthenticated teh-build-tools #Not sure this is a good idea
		cd ${TARGET}
		git clone $SERVER_USER@$SERVER_NAME:git/Build_Tools.git
		git clone $SERVER_USER@$SERVER_NAME:git/Demo_Application.git
		git clone $SERVER_USER@$SERVER_NAME:git/Demo_Library.git
		touch .development_root  # Marker to stop searches for local libraries from bubbling up too much

		;;

	setup_ssh_keys)	# Install the ssh keys so you don't have to type them all the time
		setup_ssh_keys ;;

	setup_repo)	# Install ssl keys and sources.list file
		setup_http_package_repo ;;

	upgrade) upgrade_packages ${REPOSITORY}.list
		;;

	get)	# Get an existing repository

		check_for_development_root

		check_for_git_extension $1
		[ -d ${TARGET} ] && echo -e "\n[INFO] Repository already exists!\n" && exit 0
	
		mkdir -p ${TARGET}
		git clone $SERVER_USER@$SERVER_NAME:git/${TARGET}.git ${TARGET}
		
		if [ ! $? -eq 0 ]; then
			echo -e "\n[ERROR] git clone failed... double check the name (or server ip address hardcoded in the teh script\n"
		fi
	;;

	new)	# Create a new repository on the server
		check_for_development_root
		new_repo ${TARGET}
	;;

	publish) 
		locate_project ${2}
		check_for_development_root
		# Remove old packages
		# Increment version numbers
		# Build new packages
		# Copy *.deb to repository
		# Rebuild repository index
		abort_if_project_does_not_exist ${TARGET}
		abort_if_project_is_not_active ${TARGET}
		rm -f ${TARGET}/build/*.deb	#Delete old debs

		read -p "Does $(basename ${TARGET}) have non-backward compatible changes? [y/N] " api_change
		api_change=${api_change:-N}
		if [ $api_change = "N" ]; then
			read -p "Does $(basename ${TARGET}) have new (but backward compatible) features? [y/N] " feature_change
			feature_change=${feature_change:-N}

			if [ $feature_change = "N" ]; then
				echo "Increment only build version"
				#Perl fu from the interwebs
				perl -pi.bak -e \
					's/VERSION_PATCH \"(\d+)\"/ q{VERSION_PATCH "} . (1 + $1) . q{"} /ge' \
					${TARGET}/CMakeLists.txt

			else
				echo "Increment feature version, zero build version"
				perl -pi.bak -e \
					's/VERSION_PATCH \"(\d+)\"/ q{VERSION_PATCH "} . (0) . q{"} /ge' \
					${TARGET}/CMakeLists.txt
				perl -pi.bak -e \
					's/VERSION_MINOR \"(\d+)\"/ q{VERSION_MINOR "} . (1 + $1) . q{"} /ge' \
					${TARGET}/CMakeLists.txt
			fi

		else
			echo "Increment API version, zero others"	
				perl -pi.bak -e \
					's/VERSION_PATCH \"(\d+)\"/ q{VERSION_PATCH "} . (0) . q{"} /ge' \
					${TARGET}/CMakeLists.txt
				perl -pi.bak -e \
					's/VERSION_MINOR \"(\d+)\"/ q{VERSION_MINOR "} . (0) . q{"} /ge' \
					${TARGET}/CMakeLists.txt
				perl -pi.bak -e \
					's/VERSION_MAJOR \"(\d+)\"/ q{VERSION_MAJOR "} . (1 + $1) . q{"} /ge' \
					${TARGET}/CMakeLists.txt
		fi

		if [ -d ${TARGET}/build ]; then 
			cd ${TARGET}/build; 
		else 
			echo "Project has not been built yet; do this manually!"; exit 
		fi
		cmake ..  #If the version changed we need to run cmake to update it
		make		#Just to be sure 
		cpack		#Finally do the packaging
	
		scp *.deb $SERVER_USER@$SERVER_NAME:/var/ubuntu_repo/${REPOSITORY}
		echo "sh rebuild_package_index; ls -l /var/ubuntu_repo/${REPOSITORY}" | ssh $SERVER_USER@$SERVER_NAME /bin/bash
		cd ../..
		ls ${TARGET}/build | grep deb
		

	cat <<"==="

===
;;

deactivate)
		locate_project ${2}
	check_for_development_root
	
	if [ ! -d ${TARGET}/build ]; then
		echo -e "\n ${TARGET} is either already deactivated or is not a project.\n"
		exit
	fi
	rm -rf ${TARGET}/build
;;

build) # Build project
		locate_project ${2}
	check_for_development_root

	if [ ! -d ${TARGET}/build ]; then
		mkdir ${TARGET}/build
		if [ ! $? -eq 0 ]; then 
			echo -e "\nTried to activate ${TARGET} but it does not appear to be a project director so I'm aborting! \n\n"
			exit 1
		fi
	fi
	echo -e "Activating project ${TARGET}.... You can do it by hand like this:\n\n"
	echo -e "> cd ${TARGET}; mkdir build; cd build\n> cmake ..\n> make"
	cd ${TARGET}/build
	cmake ..
	make

;;

esac

popd &>/dev/null #Return to the directory we started from
